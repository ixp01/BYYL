编译器前端测试用例集合
===================

## 1. 词法分析测试

### 1.1 基本数据类型和标识符
```c
int a;
float b;
char c;
double d;
bool flag;
```

### 1.2 数字常量
```c
int decimal = 123;
int hex = 0x1A2B;
int octal = 0755;
float pi = 3.14159;
double exp = 1.23e-4;
```

### 1.3 字符串和字符常量
```c
char ch = 'A';
char newline = '\n';
char quote = '\'';
string msg = "Hello World";
string path = "C:\\Program Files\\";
```

### 1.4 运算符测试
```c
int result = a + b - c * d / e % f;
bool cmp = (x > y) && (z <= w) || (p != q);
int bits = ~a & b | c ^ d << 2 >> 1;
```

### 1.5 注释测试
```c
// 单行注释
int x = 5; // 行末注释

/* 
 * 多行注释
 * 可以跨越多行
 */
int y = /* 内联注释 */ 10;
```

## 2. 语法分析测试

### 2.1 变量声明
```c
int a, b, c;
float x = 3.14, y = 2.71;
char name[100];
int matrix[10][20];
```

### 2.2 表达式
```c
int result = (a + b) * (c - d);
float avg = (x + y + z) / 3.0;
bool valid = (age >= 18) && (score > 60);
```

### 2.3 控制结构
```c
// if-else语句
if (x > 0) {
    printf("positive");
} else if (x < 0) {
    printf("negative");
} else {
    printf("zero");
}

// while循环
while (i < n) {
    sum += i;
    i++;
}

// for循环
for (int i = 0; i < 10; i++) {
    array[i] = i * 2;
}
```

### 2.4 函数定义
```c
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

float average(float arr[], int size) {
    float sum = 0.0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}
```

## 3. 语义分析测试

### 3.1 类型检查测试
```c
int a = 10;
float b = 3.14;
int c = a + b;  // 类型转换
char ch = 'A';
int ascii = ch; // 字符到整数转换
```

### 3.2 作用域测试
```c
int global_var = 100;

int test_scope() {
    int local_var = 200;
    {
        int block_var = 300;
        global_var = local_var + block_var;
    }
    // block_var 在此处不可见
    return local_var;
}
```

### 3.3 错误检测测试
```c
// 未声明变量使用
int x = undeclared_var;  // 错误：未声明的变量

// 重复声明
int duplicate;
int duplicate;  // 错误：重复声明

// 类型不匹配
int num;
num = "string";  // 错误：类型不匹配

// 未初始化使用
int uninitialized;
int result = uninitialized + 10;  // 警告：使用未初始化变量
```

## 4. 代码生成测试

### 4.1 简单赋值
```c
int a = 5;
int b = a;
```
期望输出：
```
1. ASSIGN  #5     -     a
2. ASSIGN  a      -     b
```

### 4.2 算术运算
```c
int a = 10;
int b = 20;
int c = a + b;
int d = c * 2;
```
期望输出：
```
1. ASSIGN  #10    -     a
2. ASSIGN  #20    -     b
3. ADD     a      b     c
4. MUL     c      #2    d
```

### 4.3 复杂表达式
```c
int x = 5;
int y = 3;
int z = (x + y) * (x - y);
```
期望输出：
```
1. ASSIGN  #5     -     x
2. ASSIGN  #3     -     y
3. ADD     x      y     t1
4. SUB     x      y     t2
5. MUL     t1     t2    z
```

### 4.4 条件语句
```c
int a = 10;
int b = 20;
if (a > b) {
    int max = a;
} else {
    int max = b;
}
```
期望输出：
```
1. ASSIGN  #10    -     a
2. ASSIGN  #20    -     b
3. GT      a      b     t1
4. IF_FALSE t1    -     L1
5. ASSIGN  a      -     max
6. GOTO    -      -     L2
7. LABEL   L1     -     -
8. ASSIGN  b      -     max
9. LABEL   L2     -     -
```

## 5. 综合测试用例

### 5.1 简单计算器程序
```c
int main() {
    int a = 10;
    int b = 5;
    int sum = a + b;
    int diff = a - b;
    int product = a * b;
    int quotient = a / b;
    return 0;
}
```

### 5.2 数组处理
```c
int main() {
    int arr[5];
    int i = 0;
    int sum = 0;
    
    for (i = 0; i < 5; i++) {
        arr[i] = i * 2;
        sum += arr[i];
    }
    
    return sum;
}
```

### 5.3 斐波那契数列
```c
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n = 10;
    int result = fibonacci(n);
    return result;
}
```

## 6. 错误处理测试

### 6.1 词法错误
```c
int @invalid_char = 5;  // 无效字符
int 123abc = 10;        // 无效标识符
```

### 6.2 语法错误
```c
int a = ;               // 缺少表达式
if (x > 0              // 缺少右括号
    printf("test");
}                       // 多余的右大括号
```

### 6.3 语义错误
```c
int function_name;
function_name();        // 尝试调用非函数
int arr[5];
arr[10] = 1;           // 数组越界（编译时可能检测不到）
```

## 使用建议

1. **逐步测试**：从简单的测试用例开始，逐步增加复杂度
2. **模块测试**：分别测试词法、语法、语义和代码生成模块
3. **错误测试**：确保编译器能正确识别和报告各种错误
4. **边界测试**：测试极限情况，如很长的标识符、深层嵌套等
5. **回归测试**：修改代码后重新运行所有测试用例

## 测试方法

1. 将测试代码输入到编译器界面
2. 观察词法分析的Token序列
3. 检查语法分析的AST结构
4. 验证语义分析的符号表和错误检测
5. 查看生成的中间代码是否正确

每个模块都应该产生预期的输出，如果有差异，需要检查相应的实现逻辑。 